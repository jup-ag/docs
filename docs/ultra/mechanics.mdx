---
title: "How Ultra Swap Works"
description: "Technical mechanics of Ultra Swap's routing engine, transaction sending, and MEV protection."
---

Understanding the internal mechanics of Ultra Swap helps you build better trading applications and optimize your integration.

## Swap Lifecycle

### 1. Quote Request (Order Creation)

When you request a swap quote through the `/order` endpoint:

```typescript
POST /ultra/v1/order

{
  "inputMint": "So11111111111111111111111111111111111111112",  // SOL
  "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC
  "amount": "1000000000",  // 1 SOL
  "slippageBps": 50        // 0.5% slippage (or omit for RTSE)
}
```

**Behind the Scenes:**

```
┌────────────────────────────────────────────────────────┐
│  Step 1: Juno Liquidity Engine Aggregation             │
├────────────────────────────────────────────────────────┤
│  Parallel quote requests to:                           │
│  • Metis Router (AMM aggregation)                      │
│  • Jupiter Z (RFQ from market makers)                  │
│  • Other liquidity sources                             │
│                                                         │
│  Latency: ~500ms                                       │
└────────────────┬───────────────────────────────────────┘
                 │
                 ↓
┌────────────────────────────────────────────────────────┐
│  Step 2: Route Comparison & Selection                  │
├────────────────────────────────────────────────────────┤
│  For each route, calculate:                            │
│  • Output amount after fees                            │
│  • Route reliability score                             │
│  • Expected execution time                             │
│  • MEV risk assessment                                 │
│                                                         │
│  Select: Best output × reliability score               │
└────────────────┬───────────────────────────────────────┘
                 │
                 ↓
┌────────────────────────────────────────────────────────┐
│  Step 3: Real-Time Slippage Estimation (if no slippage)│
├────────────────────────────────────────────────────────┤
│  If slippageBps not provided, RTSE calculates:         │
│  • Historical slippage data for token pair             │
│  • Current market volatility                           │
│  • Recent success/failure rates                        │
│  • Liquidity depth analysis                            │
│                                                         │
│  Output: Optimal slippage (balances success & price)   │
└────────────────┬───────────────────────────────────────┘
                 │
                 ↓
┌────────────────────────────────────────────────────────┐
│  Step 4: Order Response                                │
├────────────────────────────────────────────────────────┤
│  Return to client:                                     │
│  • orderId (unique identifier)                         │
│  • route (selected path)                               │
│  • inputAmount, outputAmount                           │
│  • priceImpact                                         │
│  • recommendedSlippage (if RTSE used)                  │
│  • fees breakdown                                      │
└────────────────────────────────────────────────────────┘
```

### 2. Transaction Execution

When you call `/execute` with the orderId:

```typescript
POST /ultra/v1/execute

{
  "orderId": "order_id_from_quote",
  "wallet": "user_wallet_address",
  "signature": "user_signature_or_signer"
}
```

**Execution Pipeline:**

```
┌────────────────────────────────────────────────────────┐
│  Step 1: Order Validation                              │
├────────────────────────────────────────────────────────┤
│  • Verify orderId is valid and not expired             │
│  • Check user signature/authorization                  │
│  • Validate wallet has sufficient balance              │
│  • Confirm route is still available                    │
└────────────────┬───────────────────────────────────────┘
                 │
                 ↓
┌────────────────────────────────────────────────────────┐
│  Step 2: Transaction Construction                      │
├────────────────────────────────────────────────────────┤
│  Build transaction with:                               │
│  • Swap instructions (based on selected route)         │
│  • Token account creation (if needed)                  │
│  • Fee deduction instructions                          │
│  • Slippage protection                                 │
│  • Priority fee calculation                            │
└────────────────┬───────────────────────────────────────┘
                 │
                 ↓
┌────────────────────────────────────────────────────────┐
│  Step 3: Priority Fee & Jito Tip Optimization          │
├────────────────────────────────────────────────────────┤
│  Dynamic fee calculation based on:                     │
│  • Current network congestion                          │
│  • Transaction complexity                              │
│  • User's preferred execution speed                    │
│  • MEV protection requirements                         │
│                                                         │
│  Choose between:                                       │
│  • Standard priority fee                               │
│  • Jito bundle with tip (for MEV protection)           │
└────────────────┬───────────────────────────────────────┘
                 │
                 ↓
┌────────────────────────────────────────────────────────┐
│  Step 4: Multi-RPC Broadcasting                        │
├────────────────────────────────────────────────────────┤
│  Simultaneously broadcast to:                          │
│  • Multiple high-performance RPC nodes                 │
│  • Different geographical regions                      │
│  • Jito block engine (if using Jito)                   │
│                                                         │
│  First successful propagation wins                     │
│                                                         │
│  Latency: Metis 1.5s, Jupiter Z 5s (P90)              │
└────────────────┬───────────────────────────────────────┘
                 │
                 ↓
┌────────────────────────────────────────────────────────┐
│  Step 5: Transaction Monitoring                        │
├────────────────────────────────────────────────────────┤
│  Poll for confirmation:                                │
│  • Check transaction status every 400ms                │
│  • Parse transaction logs on confirmation              │
│  • Calculate actual output amount                      │
│  • Detect any errors or failures                       │
│                                                         │
│  Timeout: 30 seconds                                   │
└────────────────┬───────────────────────────────────────┘
                 │
                 ↓
┌────────────────────────────────────────────────────────┐
│  Step 6: Result Parsing & Response                     │
├────────────────────────────────────────────────────────┤
│  Return to client:                                     │
│  • Transaction signature                               │
│  • Actual input/output amounts                         │
│  • Execution price                                     │
│  • Fees paid                                           │
│  • Route taken                                         │
│  • Success/failure status                              │
└────────────────────────────────────────────────────────┘
```

## Juno Liquidity Engine

### Multi-Source Aggregation

```
┌──────────────────────────────────────────────────────────┐
│  Juno Liquidity Engine Architecture                      │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  ┌──────────────────┐      ┌──────────────────┐         │
│  │  Metis Router    │      │  Jupiter Z (RFQ) │         │
│  │                  │      │                  │         │
│  │  • Orca          │      │  • Market Maker 1│         │
│  │  • Raydium       │      │  • Market Maker 2│         │
│  │  • Phoenix       │      │  • Market Maker 3│         │
│  │  • Lifinity      │      │  • ...           │         │
│  │  • Meteora       │      │                  │         │
│  │  • 20+ DEXes     │      │                  │         │
│  └────────┬─────────┘      └────────┬─────────┘         │
│           │                         │                    │
│           └────────┬───────────────┘                     │
│                    │                                     │
│                    ↓                                     │
│         ┌─────────────────────┐                         │
│         │  Route Optimizer    │                         │
│         │  • Price comparison │                         │
│         │  • Liquidity depth  │                         │
│         │  • Success rates    │                         │
│         │  • MEV risk         │                         │
│         └──────────┬──────────┘                         │
│                    │                                     │
│                    ↓                                     │
│         ┌─────────────────────┐                         │
│         │   Best Route        │                         │
│         └─────────────────────┘                         │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### Route Selection Algorithm

```typescript
interface RouteCandidate {
  source: 'metis' | 'jupiterz' | 'other';
  outputAmount: number;
  priceImpact: number;
  reliability: number;  // 0-1 score based on history
  mevRisk: number;      // 0-1 score
  estimatedTime: number; // milliseconds
}

function selectBestRoute(candidates: RouteCandidate[]): RouteCandidate {
  return candidates.reduce((best, current) => {
    // Calculate composite score
    const currentScore =
      current.outputAmount * current.reliability * (1 - current.mevRisk * 0.1);

    const bestScore =
      best.outputAmount * best.reliability * (1 - best.mevRisk * 0.1);

    return currentScore > bestScore ? current : best;
  });
}
```

### Self-Learning System

Juno continuously monitors performance:

```typescript
interface LiquiditySourceMetrics {
  source: string;
  successRate: number;      // % of successful executions
  avgSlippage: number;      // Average actual vs expected slippage
  avgExecutionTime: number; // Response time
  mevIncidents: number;     // Detected MEV attacks
  priceAccuracy: number;    // Quote vs actual price accuracy
}

// Sources with poor performance are sidelined
function shouldSidelineSource(metrics: LiquiditySourceMetrics): boolean {
  return (
    metrics.successRate < 0.90 ||      // <90% success
    metrics.avgSlippage > 0.02 ||      // >2% avg slippage
    metrics.mevIncidents > 5 ||        // >5 MEV incidents
    metrics.priceAccuracy < 0.95       // <95% price accuracy
  );
}
```

## Real-Time Slippage Estimator (RTSE)

### Slippage Calculation Process

When `slippageBps` is not provided in the order request:

```
┌──────────────────────────────────────────────────────┐
│  RTSE Algorithm                                       │
├──────────────────────────────────────────────────────┤
│                                                       │
│  1. Historical Analysis                              │
│     • Last 1000 swaps for this token pair            │
│     • Actual slippage experienced                    │
│     • Success vs failure rate by slippage            │
│                                                       │
│  2. Token Categorization                             │
│     • Bluechip: SOL, BTC, ETH, USDC                  │
│     • Midcap: Established tokens >$10M FDV           │
│     • Meme/Long-tail: Others                         │
│                                                       │
│  3. Exponential Moving Average (EMA)                 │
│     • Recent slippage weighted more heavily          │
│     • Detects trend changes quickly                  │
│     • Formula: EMA = α × current + (1-α) × EMA_prev  │
│                                                       │
│  4. Volatility Adjustment                            │
│     • Check last 24h price volatility                │
│     • Higher volatility → higher slippage            │
│     • Lower volatility → lower slippage              │
│                                                       │
│  5. Real-Time Monitoring                             │
│     • Current failure rate across all swaps          │
│     • If >5% failures: increase slippage by 20%      │
│     • If <1% failures: decrease slippage by 10%      │
│                                                       │
│  6. Output                                            │
│     • Recommended slippage (bps)                     │
│     • Confidence score (0-1)                         │
└──────────────────────────────────────────────────────┘
```

### RTSE Formula (Simplified)

```typescript
interface RTSEInputs {
  historicalSlippage: number[];  // Last 1000 swaps
  tokenCategory: 'bluechip' | 'midcap' | 'longtail';
  currentVolatility: number;     // 24h price volatility %
  recentFailureRate: number;     // Last 100 swaps failure rate
}

function calculateOptimalSlippage(inputs: RTSEInputs): number {
  // Calculate EMA of historical slippage
  const alpha = 0.2; // Weighting factor
  let ema = inputs.historicalSlippage[0];
  for (const slippage of inputs.historicalSlippage.slice(1)) {
    ema = alpha * slippage + (1 - alpha) * ema;
  }

  // Base slippage by token category
  const baseBps = {
    bluechip: 10,    // 0.1%
    midcap: 30,      // 0.3%
    longtail: 100    // 1.0%
  }[inputs.tokenCategory];

  // Volatility adjustment (0-50% increase)
  const volatilityMultiplier = 1 + (inputs.currentVolatility / 100) * 0.5;

  // Failure rate adjustment
  const failureAdjustment = inputs.recentFailureRate > 0.05
    ? 1.2  // +20% if high failure rate
    : inputs.recentFailureRate < 0.01
    ? 0.9  // -10% if low failure rate
    : 1.0; // No change

  // Final calculation
  const optimalSlippage =
    Math.max(baseBps, ema) * volatilityMultiplier * failureAdjustment;

  // Cap at reasonable limits
  return Math.min(optimalSlippage, 500); // Max 5%
}
```

### RTSE Performance Impact

According to Jupiter's data, RTSE improves success rates by ~10%:

| Metric | Fixed Slippage | RTSE Slippage | Improvement |
|:-------|:---------------|:--------------|:------------|
| **Success Rate** | 89% | 98% | +10% |
| **Avg Slippage** | 0.45% | 0.38% | -15% (better price) |
| **Failed Txs** | 11% | 2% | -82% failures |

## MEV Protection Mechanics

### MEV Attack Vectors

```
Common MEV attacks on Solana:
┌────────────────────────────────────────────────────┐
│  1. Sandwich Attacks                               │
│     • Frontrun: Buy before user                    │
│     • User swap: Executes at worse price           │
│     • Backrun: Sell after user                     │
│                                                     │
│  2. Just-In-Time (JIT) Liquidity                   │
│     • Add liquidity right before swap              │
│     • Capture majority of fees                     │
│     • Remove liquidity immediately after           │
│                                                     │
│  3. Priority Griefing                              │
│     • Submit failed transactions with high fees    │
│     • Causes user's lower-fee tx to fail           │
└────────────────────────────────────────────────────┘
```

### Ultra's MEV Protection

```
┌──────────────────────────────────────────────────────────┐
│  Multi-Layer MEV Protection                              │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  Layer 1: Route Selection                                │
│  • Prefer Jupiter Z (RFQ) routes                         │
│    - Firm quotes, no slippage                            │
│    - Market makers bear MEV risk                         │
│  • Avoid low-liquidity pools                             │
│                                                           │
│  Layer 2: Jito Bundles                                   │
│  • Submit transactions as Jito bundles when beneficial   │
│  • Bundle properties:                                    │
│    - All-or-nothing execution                            │
│    - Prevents frontrunning                               │
│    - Guaranteed ordering                                 │
│                                                           │
│  Layer 3: Priority Fee Optimization                      │
│  • Calculate minimum viable priority fee                 │
│  • Avoid excessive fees that attract MEV                 │
│  • Dynamic adjustment based on network state             │
│                                                           │
│  Layer 4: Transaction Obfuscation                        │
│  • Vary transaction patterns                             │
│  • Randomize submission timing                           │
│  • Use multiple RPC endpoints                            │
│                                                           │
│  Layer 5: Slippage Protection                            │
│  • Tight slippage bounds                                 │
│  • Revert on unfavorable execution                       │
│  • User never gets worse than expected price             │
│                                                           │
└──────────────────────────────────────────────────────────┘
```

### Jito Bundle Mechanics

```typescript
interface JitoBundle {
  transactions: Transaction[];
  tipAccount: PublicKey;
  tipAmount: number; // Lamports
}

// When to use Jito bundles
function shouldUseJitoBundle(swap: SwapParams): boolean {
  return (
    swap.amountUSD > 1000 ||              // Large swaps
    swap.tokenCategory === 'longtail' ||  // Volatile tokens
    swap.userPreference === 'max-protection'
  );
}

// Bundle submission
async function submitJitoBundle(bundle: JitoBundle): Promise<string> {
  // Bundle guarantees:
  // 1. Transactions execute in exact order
  // 2. No transactions inserted between bundle txs
  // 3. If any tx fails, entire bundle reverts
  // 4. Tip paid only on successful execution

  const result = await jitoClient.sendBundle(bundle);
  return result.bundleId;
}
```

### MEV Protection Results

Data from [Sandwiched.me](https://sandwiched.me/sandwiches):

| Platform | Volume (30d) | MEV Extracted | Ratio |
|:---------|:-------------|:--------------|:------|
| **Jupiter Ultra** | $45B | $180K | 0.0004% |
| Competitor A | $28B | $850K | 0.003% |
| Competitor B | $15B | $520K | 0.0035% |

Ultra has the lowest MEV extraction ratio by far.

## Transaction Sending Engine

### Multi-RPC Strategy

```
┌───────────────────────────────────────────────────────┐
│  RPC Distribution Strategy                            │
├───────────────────────────────────────────────────────┤
│                                                        │
│  Primary Broadcast                                    │
│  ├─> RPC Node 1 (US West)                            │
│  ├─> RPC Node 2 (US East)                            │
│  ├─> RPC Node 3 (EU)                                 │
│  ├─> RPC Node 4 (Asia)                               │
│  └─> Jito Block Engine (if using bundles)            │
│                                                        │
│  First to propagate wins                              │
│  Others automatically cancelled                       │
│                                                        │
│  Fallback Strategy                                    │
│  ├─> If primary fails after 2s                       │
│  ├─> Retry with increased priority fee               │
│  └─> Maximum 3 retry attempts                        │
│                                                        │
└───────────────────────────────────────────────────────┘
```

### Priority Fee Calculation

```typescript
interface PriorityFeeStrategy {
  networkCongestion: 'low' | 'medium' | 'high' | 'critical';
  transactionSize: number;  // Compute units
  userUrgency: 'normal' | 'fast' | 'turbo';
}

function calculatePriorityFee(strategy: PriorityFeeStrategy): number {
  // Base fee by network congestion
  const baseFee = {
    low: 1,        // 1 microlamport per CU
    medium: 100,   // 100 microlamports per CU
    high: 1000,    // 1000 microlamports per CU
    critical: 5000 // 5000 microlamports per CU
  }[strategy.networkCongestion];

  // User urgency multiplier
  const urgencyMultiplier = {
    normal: 1.0,
    fast: 1.5,
    turbo: 2.5
  }[strategy.userUrgency];

  // Calculate total priority fee
  const priorityFee = baseFee * strategy.transactionSize * urgencyMultiplier;

  // Convert to lamports
  return Math.ceil(priorityFee / 1_000_000);
}
```

### Confirmation Monitoring

```typescript
async function monitorTransaction(signature: string): Promise<TransactionResult> {
  const maxAttempts = 75; // 30 seconds with 400ms polling
  const pollInterval = 400; // milliseconds

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    await sleep(pollInterval);

    const status = await connection.getSignatureStatus(signature);

    if (status?.value?.confirmationStatus === 'confirmed') {
      // Parse transaction to get actual amounts
      const tx = await connection.getParsedTransaction(signature);
      return parseSwapResult(tx);
    }

    if (status?.value?.err) {
      // Transaction failed
      throw new Error(`Transaction failed: ${status.value.err}`);
    }
  }

  throw new Error('Transaction timeout');
}
```

## Gasless Mechanisms

### Jupiter Z (RFQ) Gasless

```
┌──────────────────────────────────────────────────────┐
│  RFQ Gasless Flow                                     │
├──────────────────────────────────────────────────────┤
│                                                       │
│  1. User requests swap                               │
│  2. Market maker provides firm quote                 │
│  3. Market maker is the fee payer                    │
│  4. User signs transaction (no SOL needed)           │
│  5. Market maker submits and pays fees               │
│  6. User receives output tokens                      │
│                                                       │
│  Conditions:                                          │
│  • Must route through Jupiter Z                      │
│  • Typically bluechip pairs                          │
│  • Usually $1000+ trade sizes                        │
└──────────────────────────────────────────────────────┘
```

### Gasless Support (Jupiter Sponsored)

```typescript
interface GaslessEligibility {
  tokenPair: string;
  tradeSize: number;      // USD value
  userTierpreference: string;
}

function isEligibleForGaslessSupport(params: GaslessEligibility): boolean {
  // Jupiter's algorithm (simplified)
  return (
    params.tradeSize >= 50 &&          // Minimum $50 trade
    params.tradeSize <= 10000 &&       // Maximum $10K trade
    isPopularPair(params.tokenPair) && // Common trading pairs
    hasSponsorship Available()          // Jupiter has allocated budget
  );
}

// When eligible, Jupiter adds secondary signer to pay fees
```

## Performance Optimization

### Caching Strategy

```typescript
interface CacheLayer {
  tokenMetadata: Map<string, TokenInfo>;    // TTL: 1 hour
  priceData: Map<string, number>;           // TTL: 10 seconds
  routeTemplates: Map<string, Route[]>;     // TTL: 5 minutes
  liquidityPools: Map<string, PoolInfo>;    // TTL: 30 seconds
}

// Reduces API calls and improves response time
```

### Parallel Processing

```
Order Request
    ↓
    ├──> Fetch Metis routes      │
    ├──> Fetch Jupiter Z quotes   │  Parallel
    ├──> Get token prices         │  execution
    ├──> Calculate slippage       │
    └──> Load user balances      │
         ↓
    Aggregate results
         ↓
    Return best route
```

Parallelization reduces P90 latency from ~2s to ~500ms.

## Related Documentation

- [Get Started with Ultra](/docs/ultra/get-started) - Quick start guide
- [Execute Order](/docs/ultra/execute-order) - API reference
- [Gasless Support](/docs/ultra/gasless) - Gasless mechanisms
- [MEV Protection](/docs/ultra/index#mev-protection) - Detailed MEV protection
- [Juno Routing Engine](/docs/routing) - Router documentation
