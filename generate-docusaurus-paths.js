#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Extract all paths from Docusaurus documentation structure
 */
function generateDocusaurusPaths() {
  const paths = new Set();

  // Add root path
  paths.add('/');

  /**
   * Convert file path to URL path
   */
  function fileToUrlPath(filePath, basePath = '') {
    // Remove file extension and convert to URL path
    let urlPath = filePath
      .replace(/\.(md|mdx)$/, '')
      .replace(/\/README$/, '')
      .replace(/\/index$/, '');
    
    // Add base path if provided
    if (basePath) {
      urlPath = basePath + (urlPath ? '/' + urlPath : '');
    } else if (urlPath) {
      urlPath = '/' + urlPath;
    } else {
      urlPath = '/';
    }
    
    return urlPath;
  }

  /**
   * Recursively extract paths from sidebar configuration
   */
  function extractFromSidebar(items, basePath = '') {
    if (!items) return;

    items.forEach(item => {
      if (typeof item === 'string') {
        // Simple doc reference
        const urlPath = fileToUrlPath(item, basePath);
        paths.add(urlPath);
      } else if (item.type === 'doc' && item.id) {
        // Doc item with ID
        const urlPath = fileToUrlPath(item.id, basePath);
        paths.add(urlPath);
      } else if (item.type === 'category') {
        // Category with items
        if (item.items) {
          extractFromSidebar(item.items, basePath);
        }
        
        // Category with link
        if (item.link && item.link.slug) {
          paths.add(item.link.slug.startsWith('/') ? item.link.slug : '/' + item.link.slug);
        }
      } else if (item.type === 'autogenerated' && item.dirName) {
        // Auto-generated from directory - we'll handle this with file scanning
      }
    });
  }

  /**
   * Recursively scan markdown files in directory
   */
  function scanDirectory(dirPath, basePath = '') {
    if (!fs.existsSync(dirPath)) return;

    try {
      function scanRecursive(currentPath) {
        const items = fs.readdirSync(currentPath, { withFileTypes: true });
        
        items.forEach(item => {
          const fullPath = path.join(currentPath, item.name);
          
          if (item.isDirectory() && item.name !== 'node_modules') {
            scanRecursive(fullPath);
          } else if (item.isFile() && /\.(md|mdx)$/.test(item.name)) {
            const relativePath = path.relative(dirPath, fullPath);
            const urlPath = fileToUrlPath(relativePath, basePath);
            paths.add(urlPath);
          }
        });
      }
      
      scanRecursive(dirPath);
    } catch (error) {
      console.warn(`Warning: Could not scan directory ${dirPath}:`, error.message);
    }
  }

  // Load and process sidebar configurations
  try {
    // Main docs sidebar
    if (fs.existsSync('sidebars-docs.js')) {
      const sidebarsDocs = require(path.resolve('sidebars-docs.js'));
      
      // Process each sidebar section
      Object.entries(sidebarsDocs).forEach(([sectionName, items]) => {
        if (sectionName === 'docs') {
          extractFromSidebar(items, '/docs');
        } else {
          extractFromSidebar(items, `/docs/${sectionName}`);
        }
      });
    }

    // Guides sidebar (autogenerated)
    if (fs.existsSync('sidebars-guides.js')) {
      const sidebarsGuides = require(path.resolve('sidebars-guides.js'));
      
      Object.entries(sidebarsGuides).forEach(([sectionName, items]) => {
        // For autogenerated sections, scan the directory
        scanDirectory('guides', '/guides');
      });
    }

    // API sidebar
    if (fs.existsSync('sidebars-api.js')) {
      const sidebarsApi = require(path.resolve('sidebars-api.js'));
      extractFromSidebar(sidebarsApi.api || [], '/docs/api');
    }

  } catch (error) {
    console.warn('Warning: Could not load sidebar configs:', error.message);
  }

  // Scan main content directories
  scanDirectory('docs', '/docs');
  scanDirectory('guides', '/guides');

  // Process redirects from redirects.json
  try {
    if (fs.existsSync('redirects.json')) {
      const redirects = JSON.parse(fs.readFileSync('redirects.json', 'utf8'));
      redirects.forEach(redirect => {
        if (redirect.to) {
          paths.add(redirect.to);
        }
        if (redirect.from) {
          paths.add(redirect.from);
        }
      });
    }
  } catch (error) {
    console.warn('Warning: Could not process redirects:', error.message);
  }

  // Add versioned docs if they exist
  try {
    if (fs.existsSync('docs_versions.json')) {
      const versions = JSON.parse(fs.readFileSync('docs_versions.json', 'utf8'));
      versions.forEach(version => {
        scanDirectory(`docs_versioned_docs/version-${version}`, `/docs/${version}`);
      });
    }
  } catch (error) {
    console.warn('Warning: Could not process versioned docs:', error.message);
  }

  // Convert Set to sorted array
  const sortedPaths = Array.from(paths)
    .filter(path => path && path !== '')  // Remove empty paths
    .sort();

  // Output to JSON file
  const output = {
    generator: 'docusaurus',
    timestamp: new Date().toISOString(),
    total_paths: sortedPaths.length,
    paths: sortedPaths
  };

  const outputPath = path.join(__dirname, 'docusaurus-paths.json');
  fs.writeFileSync(outputPath, JSON.stringify(output, null, 2));

  console.log(`âœ… Generated ${sortedPaths.length} Docusaurus paths`);
  console.log(`ðŸ“„ Output saved to: ${outputPath}`);
  
  return output;
}

// No external dependencies required

// Run the script
if (require.main === module) {
  generateDocusaurusPaths();
}

module.exports = { generateDocusaurusPaths }; 